---
title: "Examples: time series"
author: James Goldie
date: last-modified
format:
  html:
    code-fold: true
    resources:
      - "*.csv"
filters:
  - sverto
sverto:
  use:
    - TimeSeriesChart.svelte
---

Let's do something more useful: a time series of temperature extremes.

In Quarto, we'll download the data for two cities (Melbourne and Brisbane), letting the user choose which to display. We'll also let them choose a month and the extreme to display.

:::{.callout-tip  appearance="simple"}
In climate parlance, the highest temperature of the day is called the "daily maximum temperature", or `tmax` for short. The coldest temperature of the day is called "daily minimum temperature", or `tmin` for short.

I'm just calling them "daytime temperature" and "nighttime temperature" here â€” although the lowest temperature can technically happen during the day, it's usually at night!
:::

Once the data has been appropriately filtered and calculated, we'll pass it to our Svelte chart.

The chart is fairly agnostic in the sense that it could be used with other time series datasets too, rather than being tailored specifically to this one. It expects a prop called `data`, which is an array of objects that each have a numerical `year` and a `value`.

:::{.callout-note collapse="true" appearance="simple"}
We could generalise this chart further if we wanted: we could have it expect columns called `x` and `y`, and perhaps allow full date objects as the x values.
:::


:::{.panel-input}

##### Controls

```{ojs}
//| label: controls-city-variable
viewof selectedCity = Inputs.select(
  new Map([
    ["Melbourne", "086338"],
    ["Brisbane", "040842"]
  ]),
  {
    value: "086338"
  }
)

viewof selectedVariable = Inputs.select(
  new Map([
    ["Daytime", "tmax"],
    ["Nighttime", "tmin"]
  ]),
  {
    value: "tmax"
  }
)
```

Let's also let users select a month and whether to look at the hottest, coldest or average temperature:

```{ojs}
//| label: controls-season-metric
viewof selectedSeason = Inputs.select(
  new Map([
    ["Whole year", 0],
    ["January", 1],
    ["February", 2],
    ["March", 3],
    ["April", 4],
    ["May", 5],
    ["June", 6],
    ["July", 7],
    ["August", 8],
    ["September", 9],
    ["October", 10],
    ["November", 11],
    ["December", 12]
  ]),
  {
    value: 0
  }
)

viewof selectedMetric = Inputs.select(
  new Map([
    ["Hottest", "max"],
    ["Average", "mean"],
    ["Coldest", "min"],
  ]),
  {
    value: "Hottest"
  }
)
```

:::

Now let's use [Arquero](https://github.com/uwdata/arquero) to download and filter the selected data.


```{ojs}
//| label: download-filter-data
import { aq, op } from "@uwdata/arquero"

fullCity = aq.loadCSV(selectedVariable + "." + selectedCity + ".daily.csv")

tidiedCity = fullCity
  .rename(aq.names("date", "value"))
  .filter(d => d.date !== null)
  .params({ selectedSeason: selectedSeason })
  .derive({
    year: d => op.year(d.date),
    month: d => op.month(d.date) + 1
  })

// filter unless "Whole year" is selected
filteredCity = selectedSeason == 0 ?
  tidiedCity :
  tidiedCity.filter(d => d.month == selectedSeason)

// now group by year and calculate the metrics
allMetrics = filteredCity
  .groupby("year")
  .rollup({
    min:  d => op.min(d.value),
    mean: d => op.mean(d.value),
    max:  d => op.max(d.value),
  })

// finally, select the year and whichever metric column is chosen by the user
finalData = allMetrics
  .select("year", selectedMetric)
  .rename(aq.names("year", "value"))
```

And so we have our data! Here it is as a table, so we can see what we're sending to Svelte:

:::{.callout-note title="Table of values" collapse="true"  appearance="simple"}
```{ojs}
//| label: data-table
Inputs.table(finalData)
```
:::

But, more importantly, here it is as an animated chart:

```{ojs}
//| label: import-chart
timeSeriesChart = new TimeSeriesChart.default({
  target: document.querySelector("#chart")
})
```

:::{#chart}
:::

And there we go! And now to send our data to it:

```{ojs}
//| label: update-chart-data
timeSeriesChart.data = finalData.objects()
```

This chart also takes an additional prop: `colourScheme` can be either `cool` or `warm` (`cool` is the default). Let's set that depending on whether we're looking at daytime or nighttime temperatures:


```{ojs}
//| label: update-chart-colours
timeSeriesChart.colourScheme = selectedVariable == "tmax" ? "warm" : "cool"
```
